import os
import sys
sys.path.append(os.path.abspath('..'))
from efficient_apriori import apriori
#Further info: https://programmerclick.com/article/97871687554/
#TODO: Test in other operative systems

import numpy as np
import igraph as ig
import src.acgraph as acg
from src import utils as ut
from src.biclique import Biclique


#This module loads bicliques from BCFinder files

#BCFinder:
#http://www.imm.dtu.dk/~sljo/bcfinder/
#Authors: Sune Lehmann, Martin Schwartz and Lars Kai Hansen.


def load_bicliques(fname, gur, attnames, k, l):
    """
    It loads the bicliques from the file fname generated by BCFinder.
    gur is the access control graph where the bicliques were extracted.
    attnames is the list of attribute names of gur.
    Bicliques can be filtered by k and l:
        k=(ku,kr) is a tuple where:
            ku is the min biclique size of the top set (users)
            kr is the min biclique size of the bot set (resources)
        l is the minlen of biclique user attribute patterns

    It returns a list of Biclique objects
    """

    id = 0
    bcs = []

    usrids = []
    resids = []
    f = open(fname, 'r')
    count = 0
    for line in f.readlines():
        arr = line.split(' ')
        arr = arr[:-1] #because it has a space at the end

        if count == 0: #users
            usrids = [int(s) for s in arr]
            count += 1
        elif count == 1: #resources
            resids = [int(s) for s in arr]
            count += 1
            #Create biclique
            if len(usrids) >= k[0] and len(resids) >= k[1]:
                bc = Biclique(id=id, usrids=usrids, resids=resids)
                pattern = _compute_pattern(gur, attnames, usrids, resids, patt_minl=l)
                bc.set_pattern(pattern)
                bcs.append(bc)
                #print(id) #For debug
                id += 1

        else:
            count = 0

    f.close()

    return bcs


def _compute_pattern(gur, attnames, usrids, resids, patt_minl):
    """
    gur is an access control graph.
    attnames is the list of attribute names of gur.
    usrids is a subset list of the user ids of gur
    resids is a subset list of the resource ids of gur
    usrids and resids are completely connected in gur (a biclique)

    It returns a user attribute pattern from usrids with min_support=1.0
    and minlen=patt_minl
    If the pattern cannot be computed, it returns None
    """

    usrattvalues_list = acg.get_usrattvalues(gur, usrids, attnames)

    #Find the duplicates in the biclique to create the entries
    '''numdups_list = [] #It will have the same length as usrids
    for usrid in usrids:
        usrlabel = acg.get_usrlabel(usrid)
        vuidx = gur.vs.find(usrlabel).index
        numdups = 0
        for resid in resids:
            reslabel = acg.get_reslabel(resid)
            vridx = gur.vs.find(reslabel).index
            print(vuidx)
            e = gur.es[gur.get_eid(vuidx, vridx)]
            numdups += e['weight']
        numdups_list.append(numdups)'''

    #A temporal path
    numdups_list = []
    for usrid in usrids:
        numdups_list.append(1)




    entries = []
    for i,usrattvalues in enumerate(usrattvalues_list):
        numdups = numdups_list[i]
        for j in range(numdups):
            entries.append(usrattvalues)


    #Change the format of entries for the apriori method
    entries_t = ut.to_tuple_format(entries)
    #The pattern must have 1.0 of support
    freq_itemsets,_ = apriori(entries_t, min_support=1.0, min_confidence=1.0)

    lengths = freq_itemsets.keys()

    if len(lengths) > 0: #freq_itemsets not empty
        maxlen = max(lengths)
        if maxlen >= patt_minl: #The pattern length must be greater or equal to patt_minl
            if len(freq_itemsets[maxlen].keys()) == 1: #It has a unique pattern
                #Get pattern
                temp = list(freq_itemsets[maxlen].keys())[0]
                pattern = list(temp) #Unpack tuple of tuples
                return pattern

    return None
